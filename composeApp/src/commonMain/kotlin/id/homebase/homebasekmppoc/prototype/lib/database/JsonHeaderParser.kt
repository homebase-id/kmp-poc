package id.homebase.homebasekmppoc.prototype.lib.database

import id.homebase.homebasekmppoc.lib.database.DriveMainIndex
import kotlinx.serialization.json.Json
import kotlinx.serialization.json.jsonObject
import kotlinx.serialization.json.jsonPrimitive
import kotlinx.serialization.json.long
import kotlinx.serialization.json.contentOrNull
import kotlin.uuid.Uuid

/**
 * Parses JSON header string and extracts fields needed for DriveMainIndex
 * @param jsonHeader JSON string to parse
 * @param identityId Identity ID (required, not in JSON)
 * @param driveId Drive ID (required, not in JSON) 
 * @return DriveMainIndex with extracted fields
 * @throws IllegalArgumentException if JSON is malformed or required fields are missing
 */
fun parseJsonFileheaderToDriveMainIndex(
    jsonHeader: String,
    identityId: Uuid,
    driveId: Uuid
): DriveMainIndex {
    val json = Json { 
        ignoreUnknownKeys = true
        isLenient = false 
    }
    
    try {
        val jsonObject = json.parseToJsonElement(jsonHeader).jsonObject
        
        // Extract required fileId
        val fileIdStr = jsonObject["fileId"]?.jsonPrimitive?.contentOrNull
            ?: throw IllegalArgumentException("Missing required field: fileId")
        val fileId = Uuid.parse(fileIdStr)
        
        // Extract nested fileMetadata
        val fileMetadata = jsonObject["fileMetadata"]?.jsonObject
            ?: throw IllegalArgumentException("Missing required field: fileMetadata")
        
        // Extract fields from fileMetadata
        val globalTransitId = fileMetadata["globalTransitId"]?.jsonPrimitive?.contentOrNull?.let { 
            if (it == "null") null else Uuid.parse(it) 
        }
        val senderId = fileMetadata["senderOdinId"]?.jsonPrimitive?.contentOrNull?.let { 
            if (it == "null") null else it 
        }
        val created = fileMetadata["created"]?.jsonPrimitive?.contentOrNull?.toLongOrNull() ?: 0L
        val modified = fileMetadata["updated"]?.jsonPrimitive?.contentOrNull?.toLongOrNull() ?: created
        
        // Extract deeply nested appData
        val appData = fileMetadata["appData"]?.jsonObject
        val uniqueId = appData?.get("uniqueId")?.jsonPrimitive?.contentOrNull?.let { 
            if (it == "null") Uuid.random() else Uuid.parse(it) 
        } ?: Uuid.random() // Default to random UUID if null or missing
        val groupId = appData?.get("groupId")?.jsonPrimitive?.contentOrNull?.let { 
            if (it == "null") null else Uuid.parse(it) 
        }
        val fileType = appData?.get("fileType")?.jsonPrimitive?.contentOrNull?.toLongOrNull() ?: 0L
        val dataType = appData?.get("dataType")?.jsonPrimitive?.contentOrNull?.toLongOrNull() ?: 0L
        val archivalStatus = appData?.get("archivalStatus")?.jsonPrimitive?.contentOrNull?.toLongOrNull() ?: 0L
        val userDate = appData?.get("userDate")?.jsonPrimitive?.contentOrNull?.toLongOrNull() ?: 0L
        
        return DriveMainIndex(
            rowId = 0L, // Will be auto-generated by database
            identityId = identityId,
            driveId = driveId,
            fileId = fileId,
            uniqueId = uniqueId,
            globalTransitId = globalTransitId,
            senderId = senderId,
            groupId = groupId,
            fileType = fileType,
            dataType = dataType,
            archivalStatus = archivalStatus,
            historyStatus = 0L, // Default value
            userDate = userDate,
            created = created,
            modified = modified,
            systemFileType = 0L, // Default value
            jsonHeader = jsonHeader
        )
    } catch (e: Exception) {
        throw IllegalArgumentException("Failed to parse JSON header: ${e.message}", e)
    }
}