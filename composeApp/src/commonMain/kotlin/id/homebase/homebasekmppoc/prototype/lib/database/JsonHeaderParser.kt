package id.homebase.homebasekmppoc.prototype.lib.database

import id.homebase.homebasekmppoc.lib.database.DriveMainIndex
import id.homebase.homebasekmppoc.lib.database.DriveTagIndex
import id.homebase.homebasekmppoc.lib.database.DriveLocalTagIndex
import kotlinx.serialization.json.Json
import kotlinx.serialization.json.jsonObject
import kotlinx.serialization.json.jsonPrimitive
import kotlinx.serialization.json.contentOrNull
import kotlinx.serialization.json.JsonArray
import kotlinx.serialization.json.JsonObject
import kotlin.uuid.Uuid

/**
 * Result of parsing a JSON header containing file metadata and tag information
 */
data class ParsedHeaderResult(
    val driveMainIndex: DriveMainIndex,
    val tagIndexRecords: List<DriveTagIndex>,
    val localTagIndexRecords: List<DriveLocalTagIndex>
)

/**
 * Parses JSON header string and extracts fields needed for DriveMainIndex and tag records
 * @param jsonHeader JSON string to parse
 * @param identityId Identity ID (required, not in JSON)
 * @param driveId Drive ID (required, not in JSON) 
 * @return ParsedHeaderResult containing DriveMainIndex and tag records
 * @throws IllegalArgumentException if JSON is malformed or required fields are missing
 */
fun parseJsonHeaderToDriveMainIndex(
    identityId: Uuid,
    driveId: Uuid,
    jsonHeader: String
): ParsedHeaderResult {
    try {
        val json = Json.parseToJsonElement(jsonHeader)
        val root = json.jsonObject ?: throw IllegalArgumentException("JSON must be an object")
        
        val fileId = root["fileId"]?.jsonPrimitive?.contentOrNull?.let { 
            if (it == "null") throw IllegalArgumentException("fileId cannot be null") else Uuid.parse(it) 
        } ?: throw IllegalArgumentException("Missing fileId")
        
        val fileMetadata = root["fileMetadata"]?.jsonObject 
            ?: throw IllegalArgumentException("Missing fileMetadata")
        
        // Extract deeply nested appData
        val appData = fileMetadata["appData"]?.jsonObject
        // val localAppData = fileMetadata["localAppData"]?.jsonObject
        val localAppData: JsonObject? = fileMetadata["localAppData"] as? JsonObject
        val uniqueId = appData?.get("uniqueId")?.jsonPrimitive?.contentOrNull?.let {
            if (it == "null") Uuid.random() else Uuid.parse(it) 
        } ?: Uuid.random() // Default to random UUID if null or missing
        val groupId = appData?.get("groupId")?.jsonPrimitive?.contentOrNull?.let { 
            if (it == "null") null else Uuid.parse(it) 
        }
        val globalTransitId = fileMetadata["globalTransitId"]?.jsonPrimitive?.contentOrNull?.let { 
            if (it == "null") null else Uuid.parse(it) 
        }
        val senderId = fileMetadata["senderOdinId"]?.jsonPrimitive?.contentOrNull?.let { 
            if (it == "null") null else it 
        }
        val created = fileMetadata["created"]?.jsonPrimitive?.contentOrNull?.toLongOrNull() ?: 0L
        val modified = fileMetadata["updated"]?.jsonPrimitive?.contentOrNull?.toLongOrNull() ?: created
        
        val fileType = appData?.get("fileType")?.jsonPrimitive?.contentOrNull?.toLongOrNull() ?: 0L
        val dataType = appData?.get("dataType")?.jsonPrimitive?.contentOrNull?.toLongOrNull() ?: 0L
        val archivalStatus = appData?.get("archivalStatus")?.jsonPrimitive?.contentOrNull?.toLongOrNull() ?: 0L
        val userDate = appData?.get("userDate")?.jsonPrimitive?.contentOrNull?.toLongOrNull() ?: 0L
        
        // Extract tags from appData.tags
        val tagIndexRecords = appData?.get("tags")?.let { tagsElement ->
            if (tagsElement is JsonArray && tagsElement.isNotEmpty()) {
                tagsElement.mapNotNull { tagElement ->
                    tagElement.jsonPrimitive.contentOrNull?.let { tagStr ->
                        if (tagStr != "null") {
                            try {
                                val tagId = Uuid.parse(tagStr)
                                DriveTagIndex(
                                    rowId = 0L, // Will be auto-generated by database
                                    identityId = identityId,
                                    driveId = driveId,
                                    fileId = fileId,
                                    tagId = tagId
                                )
                            } catch (e: IllegalArgumentException) {
                                null // Skip invalid UUIDs
                            }
                        } else null
                    }
                }
            } else emptyList()
        } ?: emptyList()

        // Extract tags from appData.tags
        val localTagIndexRecords = localAppData?.get("tags")?.let { tagsElement ->
            if (tagsElement is JsonArray && tagsElement.isNotEmpty()) {
                tagsElement.mapNotNull { tagElement ->
                    tagElement.jsonPrimitive.contentOrNull?.let { tagStr ->
                        if (tagStr != "null") {
                            try {
                                val tagId = Uuid.parse(tagStr)
                                DriveLocalTagIndex(
                                    rowId = 0L, // Will be auto-generated by database
                                    identityId = identityId,
                                    driveId = driveId,
                                    fileId = fileId,
                                    tagId = tagId
                                )
                            } catch (e: IllegalArgumentException) {
                                null // Skip invalid UUIDs
                            }
                        } else null
                    }
                }
            } else emptyList()
        } ?: emptyList()


        val driveMainIndex = DriveMainIndex(
            rowId = 0L, // Will be auto-generated by database
            identityId = identityId,
            driveId = driveId,
            fileId = fileId,
            globalTransitId = globalTransitId,
            senderId = senderId,
            uniqueId = uniqueId,
            groupId = groupId,
            fileType = fileType,
            dataType = dataType,
            archivalStatus = archivalStatus,
            historyStatus = 0L,
            userDate = userDate,
            created = created,
            modified = modified,
            systemFileType = 0L, // Default value
            jsonHeader = jsonHeader
        )
        
        return ParsedHeaderResult(
            driveMainIndex = driveMainIndex,
            tagIndexRecords = tagIndexRecords,
            localTagIndexRecords = localTagIndexRecords
        )
    } catch (e: Exception) {
        throw IllegalArgumentException("Failed to parse JSON header: ${e.message}", e)
    }
}