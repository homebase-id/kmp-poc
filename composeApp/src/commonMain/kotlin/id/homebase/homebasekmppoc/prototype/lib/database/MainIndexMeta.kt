package id.homebase.homebasekmppoc.prototype.lib.database

import id.homebase.homebasekmppoc.lib.database.DriveMainIndex
import id.homebase.homebasekmppoc.lib.database.OdinDatabase
import id.homebase.homebasekmppoc.prototype.lib.drives.SharedSecretEncryptedFileHeader
import id.homebase.homebasekmppoc.prototype.lib.serialization.OdinSystemSerializer
import id.homebase.homebasekmppoc.prototype.lib.drives.query.QueryBatchCursor
import kotlin.uuid.Uuid

/**
 * Helper functions for DriveMainIndex operations
 */
object MainIndexMetaHelpers {
   /**
     * Helper upsert function that takes a DriveMainIndex record and calls
     * database.upsertDriveMainIndex() with all the members.
     */
    fun upsertDriveMainIndex(
       database: OdinDatabase,
       driveMainIndexRecord: DriveMainIndex
    ) {
        database.driveMainIndexQueries.upsertDriveMainIndex(
            identityId = driveMainIndexRecord.identityId,
            driveId = driveMainIndexRecord.driveId,
            fileId = driveMainIndexRecord.fileId,
            globalTransitId = driveMainIndexRecord.globalTransitId,
            uniqueId = driveMainIndexRecord.uniqueId,
            groupId = driveMainIndexRecord.groupId,
            senderId = driveMainIndexRecord.senderId,
            fileType = driveMainIndexRecord.fileType,
            dataType = driveMainIndexRecord.dataType,
            archivalStatus = driveMainIndexRecord.archivalStatus,
            historyStatus = driveMainIndexRecord.historyStatus,
            userDate = driveMainIndexRecord.userDate,
            created = driveMainIndexRecord.created,
            modified = driveMainIndexRecord.modified,
            systemFileType = driveMainIndexRecord.systemFileType,
            jsonHeader = driveMainIndexRecord.jsonHeader,
        )
    }
}

/**
 * Processes file metadata with associated tags from different index tables.
 * Takes a DriveMainIndex record and lists of DriveTagIndex and DriveLocalTagIndex records.
 */
class FileHeaderProcessor(
    private val database: OdinDatabase
) {

    fun deleteEntryDriveMainIndex(
        database: OdinDatabase,
        identityId : Uuid,
        driveId : Uuid,
        fileId : Uuid
    ) {
        database.transaction {
            database.driveMainIndexQueries.deleteBy(identityId, driveId, fileId)
            database.driveTagIndexQueries.deleteByFile(identityId,driveId,fileId)
            database.driveLocalTagIndexQueries.deleteByFile(identityId,driveId,fileId)
        }
    }


    /**
     * Converts SharedSecretEncryptedFileHeader to ParsedHeaderResult
     * 
     * @param identityId Identity ID (required, not in header)
     * @param driveId Drive ID (required, not in header)
     * @param header SharedSecretEncryptedFileHeader containing file metadata
     * @return ParsedHeaderResult containing DriveMainIndex and tag records
     */
    fun convertFileHeaderToDriveMainIndexRecord(
        identityId: Uuid,
        driveId: Uuid,
        header: SharedSecretEncryptedFileHeader
    ): DriveMainIndex {
        // Serialize header back to JSON for storage
        val jsonHeader = OdinSystemSerializer.serialize(header)

        val driveMainIndex = DriveMainIndex(
            rowId = 0L, // Will be auto-generated by database
            identityId = identityId,
            driveId = driveId,
            fileId = header.fileId,
            uniqueId = header.fileMetadata.appData.uniqueId,
            globalTransitId = header.fileMetadata.globalTransitId,
            senderId = header.fileMetadata.senderOdinId,
            groupId = header.fileMetadata.appData.groupId,
            fileType = (header.fileMetadata.appData.fileType ?: 0).toLong(),
            dataType = (header.fileMetadata.appData.dataType ?: 0).toLong(),
            archivalStatus = (header.fileMetadata.appData.archivalStatus?.value ?: 0).toLong(),
            historyStatus = 0L,
            userDate = header.fileMetadata.appData.userDate ?: 0L,
            created = header.fileMetadata.created.milliseconds,
            modified = header.fileMetadata.updated.milliseconds,
            systemFileType = 0L, // Default value
            jsonHeader = jsonHeader
        )

        return driveMainIndex
    }

    /**
     * Converts DriveMainIndex.jsonHeader back to SharedSecretEncryptedFileHeader
     * This is the inverse function of convertFileHeaderToDriveMainIndexRecord
     * 
     * @param driveMainIndex DriveMainIndex record containing the jsonHeader
     * @return SharedSecretEncryptedFileHeader reconstructed from the stored JSON
     * @throws Exception if JSON deserialization fails
     */
    fun convertDriveMainIndexRecordToFileHeader(
        driveMainIndex: DriveMainIndex
    ): SharedSecretEncryptedFileHeader {
        return OdinSystemSerializer.deserialize<SharedSecretEncryptedFileHeader>(driveMainIndex.jsonHeader)
    }

    /**
     * Upserts multiple file entries into the database using the provided SharedSecretEncryptedFileHeaders
     * All operations are performed within a single database transaction for atomicity.
     * 
     * @param identityId Identity ID (required, not in header)
     * @param driveId Drive ID (required, not in header)
     * @param fileHeaders List of SharedSecretEncryptedFileHeader containing file metadata
     * @param cursor Optional current cursor to be saved
     */
    fun BaseUpsertEntryZapZap(
        identityId: Uuid,
        driveId: Uuid,
        fileHeaders: List<SharedSecretEncryptedFileHeader>,
        cursor : QueryBatchCursor?
    ) {
        database.transaction {
            fileHeaders.forEach { fileHeader ->
                // Convert SharedSecretEncryptedFileHeader to extract DriveMainIndex fields and tag records
                val driveMainIndexRecord = convertFileHeaderToDriveMainIndexRecord(identityId, driveId, fileHeader)

                MainIndexMetaHelpers.upsertDriveMainIndex(database, driveMainIndexRecord)

                database.driveTagIndexQueries.deleteByFile(identityId = identityId, driveId = driveId, fileId = driveMainIndexRecord.fileId)
                database.driveLocalTagIndexQueries.deleteByFile(identityId = identityId, driveId = driveId, fileId = driveMainIndexRecord.fileId)

                fileHeader.fileMetadata.appData.tags?.forEach { tagRecord ->
                    database.driveTagIndexQueries.insertTag(
                        identityId = identityId,
                        driveId = driveId,
                        fileId = driveMainIndexRecord.fileId,
                        tagId = tagRecord
                    )
                }

                fileHeader.fileMetadata.localAppData?.tags?.forEach { tagRecord ->
                    database.driveLocalTagIndexQueries.insertLocalTag(
                        identityId = identityId,
                        driveId = driveId,
                        fileId = driveMainIndexRecord.fileId,
                        tagId = tagRecord
                    )
                }
            }

            if (cursor != null)
            {
                val cursorSync = CursorSync(database)
                cursorSync.saveCursor(cursor)
            }
        }
    }

    /**
     * Upserts a single file entry into the database using the provided SharedSecretEncryptedFileHeader
     * This is a backwards-compatible helper that calls the batch version with a single-item list.
     * 
     * @param identityId Identity ID (required, not in header)
     * @param driveId Drive ID (required, not in header)
     * @param fileHeader SharedSecretEncryptedFileHeader containing file metadata
     * @param cursor Optional current cursor to be saved
     */
    fun BaseUpsertEntryZapZap(
        identityId: Uuid,
        driveId: Uuid,
        fileHeader: SharedSecretEncryptedFileHeader,
        cursor : QueryBatchCursor?
    ) {
        BaseUpsertEntryZapZap(identityId, driveId, listOf(fileHeader), cursor)
    }
}
