package id.homebase.homebasekmppoc.prototype.lib.database

import id.homebase.homebasekmppoc.lib.database.DriveMainIndex
import id.homebase.homebasekmppoc.lib.database.OdinDatabase
import id.homebase.homebasekmppoc.prototype.lib.drives.HomebaseFile
import id.homebase.homebasekmppoc.prototype.lib.serialization.OdinSystemSerializer
import id.homebase.homebasekmppoc.prototype.lib.drives.query.QueryBatchCursor
import kotlin.uuid.Uuid

/**
 * Helper functions for DriveMainIndex operations
 */
object MainIndexMetaHelpers {
    /**
     * Helper upsert function that takes a DriveMainIndex record and calls
     * database.upsertDriveMainIndex() with all the members.
     */
    suspend fun upsertDriveMainIndex(
        databaseManager: DatabaseManager,
        driveMainIndexRecord: DriveMainIndex
    ) {
        databaseManager.driveMainIndex.upsertDriveMainIndex(
            identityId = driveMainIndexRecord.identityId,
            driveId = driveMainIndexRecord.driveId,
            fileId = driveMainIndexRecord.fileId,
            globalTransitId = driveMainIndexRecord.globalTransitId,
            uniqueId = driveMainIndexRecord.uniqueId,
            groupId = driveMainIndexRecord.groupId,
            senderId = driveMainIndexRecord.senderId,
            fileType = driveMainIndexRecord.fileType,
            dataType = driveMainIndexRecord.dataType,
            archivalStatus = driveMainIndexRecord.archivalStatus,
            historyStatus = driveMainIndexRecord.historyStatus,
            userDate = driveMainIndexRecord.userDate,
            created = driveMainIndexRecord.created,
            modified = driveMainIndexRecord.modified,
            fileSystemType = driveMainIndexRecord.fileSystemType,
            jsonHeader = driveMainIndexRecord.jsonHeader,
        )
    }

    fun upsertDriveMainIndex(
        db : OdinDatabase,
        driveMainIndexRecord: DriveMainIndex
    ) : Long {
        return db.driveMainIndexQueries.upsertDriveMainIndex(
            identityId = driveMainIndexRecord.identityId,
            driveId = driveMainIndexRecord.driveId,
            fileId = driveMainIndexRecord.fileId,
            globalTransitId = driveMainIndexRecord.globalTransitId,
            uniqueId = driveMainIndexRecord.uniqueId,
            groupId = driveMainIndexRecord.groupId,
            senderId = driveMainIndexRecord.senderId,
            fileType = driveMainIndexRecord.fileType,
            dataType = driveMainIndexRecord.dataType,
            archivalStatus = driveMainIndexRecord.archivalStatus,
            historyStatus = driveMainIndexRecord.historyStatus,
            userDate = driveMainIndexRecord.userDate,
            created = driveMainIndexRecord.created,
            modified = driveMainIndexRecord.modified,
            fileSystemType = driveMainIndexRecord.fileSystemType,
            jsonHeader = driveMainIndexRecord.jsonHeader,
        ).value
    }

    /**
     * Processes file metadata with associated tags from different index tables.
     * Takes a DriveMainIndex record and lists of DriveTagIndex and DriveLocalTagIndex records.
     */
    class HomebaseFileProcessor(
        private val databaseManager: DatabaseManager
    ) {
        suspend fun deleteEntryDriveMainIndex(
            identityId: Uuid,
            driveId: Uuid,
            fileId: Uuid
        ) {
            databaseManager.withWriteTransaction { db ->
                db.driveMainIndexQueries.deleteBy(identityId, driveId, fileId)
                db.driveTagIndexQueries.deleteByFile(identityId, driveId, fileId)
                db.driveLocalTagIndexQueries.deleteByFile(identityId, driveId, fileId)
            }
        }


        /**
         * Converts SharedSecretEncryptedFileHeader to ParsedHeaderResult
         *
         * @param identityId Identity ID (required, not in header)
         * @param driveId Drive ID (required, not in header)
         * @param header SharedSecretEncryptedFileHeader containing file metadata
         * @return ParsedHeaderResult containing DriveMainIndex and tag records
         */
        fun convertFileHeaderToDriveMainIndexRecord(
            identityId: Uuid,
            driveId: Uuid,
            header: HomebaseFile
        ): DriveMainIndex {
            // Serialize header back to JSON for storage
            val jsonHeader = OdinSystemSerializer.serialize(header)

            val driveMainIndex = DriveMainIndex(
                rowId = 0L, // Will be auto-generated by database
                identityId = identityId,
                driveId = driveId,
                fileId = header.fileId,
                uniqueId = header.fileMetadata.appData.uniqueId,
                globalTransitId = header.fileMetadata.globalTransitId,
                senderId = header.fileMetadata.senderOdinId,
                groupId = header.fileMetadata.appData.groupId,
                fileType = (header.fileMetadata.appData.fileType ?: 0).toLong(),
                dataType = (header.fileMetadata.appData.dataType ?: 0).toLong(),
                archivalStatus = (header.fileMetadata.appData.archivalStatus?.value ?: 0).toLong(),
                historyStatus = 0L,
                userDate = header.fileMetadata.appData.userDate ?: 0L,
                created = header.fileMetadata.created.milliseconds,
                modified = header.fileMetadata.updated.milliseconds,
                fileSystemType = 0L, // Default value
                jsonHeader = jsonHeader
            )

            return driveMainIndex
        }

        /**
         * Converts DriveMainIndex.jsonHeader back to SharedSecretEncryptedFileHeader
         * This is the inverse function of convertFileHeaderToDriveMainIndexRecord
         *
         * @param driveMainIndex DriveMainIndex record containing the jsonHeader
         * @return SharedSecretEncryptedFileHeader reconstructed from the stored JSON
         * @throws Exception if JSON deserialization fails
         */
        fun convertDriveMainIndexRecordToFileHeader(
            driveMainIndex: DriveMainIndex
        ): HomebaseFile {
            return OdinSystemSerializer.deserialize<HomebaseFile>(driveMainIndex.jsonHeader)
        }

        /**
         * Upserts multiple file entries into the database using the provided SharedSecretEncryptedFileHeaders
         * All operations are performed within a single thread-safe database transaction for atomicity.
         * otherwise uses direct database transaction (for tests).
         *
         * @param identityId Identity ID (required, not in header)
         * @param driveId Drive ID (required, not in header)
         * @param fileHeaders List of SharedSecretEncryptedFileHeader containing file metadata
         * @param cursor Optional current cursor to be saved
         */
        suspend fun baseUpsertEntryZapZap(
            identityId: Uuid,
            driveId: Uuid,
            fileHeaders: List<HomebaseFile>,
            cursor: QueryBatchCursor?
        ) {
                performBaseUpsert(identityId, driveId, fileHeaders, cursor)
        }

        /**
         * Internal helper method that performs the actual upsert operations.
         * Separated to avoid code duplication between transaction strategies.
         * Made public for testing thread safety within transactions.
         */
        suspend fun performBaseUpsert(
            identityId: Uuid,
            driveId: Uuid,
            fileHeaders: List<HomebaseFile>,
            cursor: QueryBatchCursor?
        ) {
            databaseManager.withWriteTransaction { db ->

                fileHeaders.forEach { fileHeader ->
                    // Convert SharedSecretEncryptedFileHeader to extract DriveMainIndex fields and tag records
                    val driveMainIndexRecord = convertFileHeaderToDriveMainIndexRecord(identityId, driveId, fileHeader)

                    var n = upsertDriveMainIndex(db, driveMainIndexRecord)

                    if (n != 1L)
                        throw IllegalStateException("Unable to write row")

                    db.driveTagIndexQueries.deleteByFile(
                        identityId = identityId,
                        driveId = driveId,
                        fileId = driveMainIndexRecord.fileId
                    )
                    db.driveLocalTagIndexQueries.deleteByFile(
                        identityId = identityId,
                        driveId = driveId,
                        fileId = driveMainIndexRecord.fileId
                    )

                    n = 0L
                    var l = 0L
                    fileHeader.fileMetadata.appData.tags?.forEach { tagRecord ->
                        // println("Insert Tag ${driveMainIndexRecord.fileId}: $tagRecord")
                        n += db.driveTagIndexQueries.insertTag(
                            identityId = identityId,
                            driveId = driveId,
                            fileId = driveMainIndexRecord.fileId,
                            tagId = tagRecord
                        ).value
                        l++;
                    }
                    if (n != l)
                        throw IllegalStateException("Unable to write TAGs")

                    n = 0L
                    l = 0L
                    fileHeader.fileMetadata.localAppData?.tags?.forEach { tagRecord ->
                        // println("Insert Local Tag ${driveMainIndexRecord.fileId}: $tagRecord")
                        n += db.driveLocalTagIndexQueries.insertLocalTag(
                            identityId = identityId,
                            driveId = driveId,
                            fileId = driveMainIndexRecord.fileId,
                            tagId = tagRecord
                        ).value
                        l++;
                    }

                    if (n != l)
                        throw IllegalStateException("Unable to write TAGs")

                    if (cursor != null) {
                        val cursorStorage = CursorStorage(databaseManager, driveId)
                        cursorStorage.saveCursor(db, cursor)
                    }
                }
            }
        }

        /**
         * Upserts a single file entry into the database using the provided SharedSecretEncryptedFileHeader
         * This is a backwards-compatible helper that calls the batch version with a single-item list.
         *
         * @param identityId Identity ID (required, not in header)
         * @param driveId Drive ID (required, not in header)
         * @param fileHeader SharedSecretEncryptedFileHeader containing file metadata
         * @param cursor Optional current cursor to be saved
         */
        suspend fun baseUpsertEntryZapZap(
            identityId: Uuid,
            driveId: Uuid,
            fileHeader: HomebaseFile,
            cursor: QueryBatchCursor?
        ) {
            baseUpsertEntryZapZap(identityId, driveId, listOf(fileHeader), cursor)
        }
    }
}
